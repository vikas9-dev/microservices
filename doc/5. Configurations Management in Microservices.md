# Configurations Management in Microservices

In this section, we will discuss another Challenge, a crucial issue faced while building microservices or cloud-native applications—**Configuration Management**.

### Understanding the Challenge

One of the key principles of microservices is **separating configuration from business logic**. Unlike monolithic applications, where configurations are tightly coupled with the code, microservices require a different approach.

Here are some critical questions that arise when managing configurations in a microservices architecture:

- **How do we separate configurations from business logic?**

  - If we bundle configurations with the business logic, we must create separate Docker images for each environment. This is inefficient and goes against best practices.
  - The same Docker image should be reusable across all environments.

- **How do we inject configuration at runtime?**

  - Some sensitive configurations, such as credentials, cannot be hardcoded inside the business logic.
  - These must be injected securely at the time of service startup.

- **How do we manage configurations centrally?**
  - In monolithic applications, managing configurations manually may be feasible.
  - However, in microservices, where there could be **hundreds of services**, it becomes challenging to track configurations for each one.
  - A centralized configuration repository with version control is essential.

### Solutions for Configuration Management in Microservices

To tackle these challenges, multiple solutions are available within the **Spring Boot ecosystem**:

1. **Basic Approach:** Configuring Spring Boot with application properties and profiles.
2. **External Configuration Approach:** Storing configurations outside the microservice and injecting them at runtime.
3. **Spring Cloud Config Server:** A dedicated configuration server that manages all microservice configurations centrally.

Throughout this section, we will explore and implement these approaches in our **Accounts, Loans, and Cards** microservices.

### Traditional vs. Modern Configuration Management

**Traditional Applications (Monolithic Architecture)**

- Configurations are bundled with the source code.
- Any change in the configuration requires a rebuild and redeployment.
- There is no guarantee of consistency across environments.

**Microservices-Based Architecture**

- Configurations must be **externalized** from the business logic.
- The same **immutable artifact (Docker image)** is used across all environments.
- Configuration is injected dynamically based on the target environment (Dev, QA, Prod).

### Recommended Approach

Following the **12-Factor App methodology**, configurations that change between deployments (e.g., credentials, URLs) should be **stored separately** and injected at runtime.

The deployment process typically follows this workflow:

1. The **source code** is stored in a **GitHub repository**.
2. The application is **compiled and packaged** into a build (Docker image).
3. The **same build** is used across all environments (Dev, QA, Prod).
4. **Configuration is injected dynamically** at runtime, ensuring flexibility and security.

This approach ensures **consistency** across environments while keeping application artifacts **immutable**.

---

## 2. Basics of Configuration Management in Spring Boot

Since we are building our microservices using **Spring Boot**, it’s essential to understand how configuration management works within this framework. Spring Boot provides multiple ways to **externalize configurations**, ensuring that the same **immutable code artifact** can be reused across different environments without requiring a rebuild.

In this section, we will explore the **basic configuration approaches** available in Spring Boot before moving to advanced solutions like **Spring Cloud Config Server**.

---

### Why Externalize Configuration?

The **main challenge** in microservices configuration management is separating **business logic from configurations**.

- If **configuration is bundled with the code**, we need to **rebuild the application** for every environment change.
- The **recommended approach** is to keep the **same application build** across all environments and inject configurations dynamically.

Spring Boot allows us to achieve this by **externalizing configurations** using various approaches.

---

### Configuration Sources in Spring Boot

Spring Boot provides **multiple ways** to specify configuration properties:

1. **Property Files & YAML Files** (`application.properties` or `application.yml`)
2. **Environment Variables** (set at the OS level)
3. **Command-Line Arguments** (passed when starting the application)
4. **Java System Properties** (`-Dproperty=value` in JVM options)
5. **Servlet Config & Init Parameters** (for web applications)

By default, Spring Boot looks for **`application.properties`** or **`application.yml`** in the **classpath location**. However, we can override these properties at runtime using **environment variables or command-line arguments**.

---

### Spring Boot Configuration Priority Order

If the **same property** is defined in multiple places, **Spring Boot follows a priority order** when resolving its value:

| Priority        | Configuration Source                                        |
| --------------- | ----------------------------------------------------------- |
| **1** (Highest) | Command-Line Arguments (`--property=value`)                 |
| **2**           | Java System Properties (`-Dproperty=value`)                 |
| **3**           | OS Environment Variables                                    |
| **4**           | `application.properties` / `application.yml` (in classpath) |

**Lower priority sources** (e.g., `application.properties`) can be **overridden** by **higher-priority sources** (e.g., environment variables or command-line arguments).

---

### How to Read Configuration Properties in Spring Boot?

Once the configuration properties are defined, we need **ways to access them** inside our business logic. Here are three commonly used approaches:

#### 1. **Using `@Value` Annotation**

The simplest way to read a single property is by using the `@Value` annotation:

```java
@Value("${server.port}")
private String serverPort;
```

- `server.port` will be **injected** from the property file or environment variables.
- **Limitations**: Requires **hardcoding** property names and is not efficient for multiple properties.

---

#### 2. **Using `Environment` Interface**

For **dynamic configurations**, we can use the `Environment` interface provided by Spring Boot:

```java
@Autowired
private Environment environment; // Import from Spring Boot (not from Hibernate)

@GetMapping("/java-version")
public ResponseEntity<String> getJavaVersion() {
    return ResponseEntity.ok().body(env.getProperty("JAVA_HOME"));
}
```

Another Example:-

```java
@Autowired
private Environment environment;

public String getDatabaseUrl() {
    return environment.getProperty("spring.datasource.url");
}
```

- Useful when configurations come from **environment variables**.
- **More flexible** than `@Value`, but still involves **manual property retrieval**.

---

#### 3. **Using `@ConfigurationProperties`** (Recommended for Multiple Properties)

When working with **multiple related properties**, we should use `@ConfigurationProperties`:

1. **Define properties with a common prefix** in `application.yml`:

```yaml
accounts:
  message: "Accounts Microservice"
  contactDetails:
    name: "Accounts Microservice - Developer"
    email: "0V7ZD@example.com"
  onCallSupport:
    - (555) 555-5555
    - (555) 555-5556
```

2. **Create a Java class to bind properties:**

```java
@Component
@ConfigurationProperties(prefix = "accounts")
@Setter
@Getter
public class AccountsContactDto {
    private String message;
    private Map<String, String> contactDetails;
    private List<String> onCallSupport;
}
```

3. **Inject and use the properties:**

```java
@Autowired
private AccountsContactDto contactDto;

@GetMapping("/contact-info")
public ResponseEntity<AccountsContactDto> getContactDetails() {
    return ResponseEntity.ok().body(contactDto);
}
```

- **Benefits**:  
  ✅ Avoids hardcoding property names  
  ✅ Supports **multiple properties** binding  
  ✅ More **structured** and **scalable**

We can replace the AccountsContactDto class with a Java 17 record type if we prefer. Using Java 17 record instead of a simple class has several advantages, particularly when dealing with data-holding classes like DTOs (Data Transfer Objects).

- A record is implicitly final and cannot be extended.
- Its fields are final and cannot be modified after creation.
- This makes it thread-safe and prevents unintended modifications.

```java
@ConfigurationProperties(prefix = "accounts")
public record AccountsContactDto(String message, Map<String, String> contactDetails, List<String> onCallSupport) {
}
```

Ensure you have @EnableConfigurationProperties in your configuration class:

```java
@EnableConfigurationProperties(value = {AccountsContactDto.class})
public class AccountsController {
    @Autowired
    private AccountsContactDto contactDto;

    @GetMapping("/contact-info")
    public ResponseEntity<AccountsContactDto> getContactDetails() {
        return ResponseEntity.ok().body(contactDto);
    }
}
```

---

Spring Boot provides **various ways** to manage configurations. The **recommended approach** depends on **how many properties** you need to handle:

- ✅ Use `@Value` for **few** properties.
- ✅ Use `Environment` for **dynamic configurations**.
- ✅ Use `@ConfigurationProperties` for **large sets of properties**.

---

## 3. Managing Configurations with Spring Boot Profiles

In microservices development, different environments (such as **Development, QA, and Production**) often require **different configuration values**. For example, **database credentials** and **API endpoints** should vary between **local development, QA, and production** environments.

Spring Boot provides a powerful feature called **Profiles**, which allows us to define **environment-specific configurations** without modifying the application code.

---

### **Why Use Profiles?**

By default, Spring Boot loads properties from **`application.properties`** or **`application.yml`**. However, these properties **remain the same across all environments**.

✅ **Profiles allow us to:**

- Define **different configuration values** for different environments.
- **Avoid modifying the code** when switching environments.
- **Dynamically activate** the required profile at runtime.
- Control the **creation of Spring beans** based on the active profile.

---

### **How to Define Profiles in Spring Boot**

Spring Boot allows us to **group configurations** into separate profile-specific files:

| Environment         | Configuration File     |
| ------------------- | ---------------------- |
| **Default (Local)** | `application.yml`      |
| **QA**              | `application-qa.yml`   |
| **Production**      | `application-prod.yml` |

File Naming Convention: `application-{profile}.yml`. Use hyphens to separate the profile name instead of underscores because in later stage while working with spring cloud config server, it will be easier to manage the profiles.

#### **Example: Creating Profile-Specific YAML Files**

1️⃣ **Default Configurations (`application.yml`)**

```yaml
spring:
#  profiles:
#    active: qa
  config:
    import:
      optionals:
        - "application-${spring.profiles.active}.yml"

build:
  version: "3.0"
```

2️⃣ **QA Environment (`application-qa.yml`)**

```yaml
spring:
  config:
    active:
      on-profile: qa

build:
  version: "2.0"
```

3️⃣ **Production Environment (`application-prod.yml`)**

```yaml
spring:
  config:
    active:
      on-profile: prod

build:
  version: "1.0"
```

---

### **Activating a Profile**

We can **activate a profile** using different methods:

#### ✅ **Method 1: Inside `application.yml`**

Add the following property to activate a profile:

```yaml
spring:
  profiles:
    active: qa
```

---

### **Using Profiles to Control Bean Creation**

Profiles can also be used to **conditionally create beans** based on the environment.

```java
@Configuration
@Profile("prod")
public class ProdConfig {

    @Bean
    public DataSource dataSource() {
        return new HikariDataSource(); // Production database connection pool
    }
}
```

If the **`prod` profile** is **active**, Spring will only create this **`dataSource` bean**.

**Key Benefits of Using Profiles**

✅ **Seamless environment switching** → No need to modify the code.  
✅ **Prevents sensitive data leakage** → Environment variables can store credentials securely.  
✅ **Ensures application consistency** → The same **immutable build** can be used across environments.

**Limitations of Using Profiles**: Suppose if I want to change some properties inside a production environment, or suppose if I want to activate the production profile, then I need to change this value and then regenerate the Docker image. With that, we are not making our code base as immutable. That's why let's try to explore what are the various options that we have to change the property values dynamically during the startup through an external parameter.

---

## 4. Externalizing Configurations in Spring Boot

One of the core principles of microservices and cloud-native applications is **externalized configuration**. Instead of **hardcoding profile values** inside `application.yml`, we should activate and manage configurations dynamically based on the deployment environment.

Spring Boot provides multiple ways to achieve this without rebuilding or modifying the application package. Let’s explore these approaches.

**Why Externalize Configurations?**

If we **hardcode** profile values inside `application.yml`, we must **modify and rebuild** the application whenever we switch environments (e.g., from **Dev to QA to Prod**). This violates the **15-Factor Methodology**, which recommends **immutable artifacts** across deployments.

By **externalizing configurations**, we can:  
✅ Activate different profiles dynamically **without rebuilding the application**.  
✅ Manage **environment-specific settings** separately from the codebase.  
✅ Improve security by keeping **sensitive credentials out of the code**.  
✅ Ensure **portability** across multiple deployment platforms.

### **Approaches for Externalizing Configurations**

Spring Boot provides several methods to activate profiles and set external configurations dynamically.

#### **1️⃣ Command-Line Arguments (Highest Priority)**

Command-line arguments provide the **highest precedence** among all configuration sources in Spring Boot.

##### **Syntax:**

```bash
java -jar myapp.jar --spring.profiles.active=prod --server.port=8082
```
Example:-
```bash
java -jar target/accounts-0.0.1-SNAPSHOT.jar --build.version=5.9
```

##### **Key Points:**

✅ Overrides values set in `application.yml`.  
✅ Allows **dynamic profile selection** at runtime.  
✅ Supports multiple key-value pairs (separated by spaces).

#### **2️⃣ JVM System Properties (-D option)**

JVM system properties provide another way to **pass externalized configurations** at runtime.

##### **Syntax:**

```bash
java -Dspring.profiles.active=prod -Dserver.port=8082 -jar myapp.jar
```
Example:-
```bash
java -Dbuild.version=9.9 -jar target/accounts-0.0.1-SNAPSHOT.jar
```
##### **Key Points:**

✅ Has **lower precedence** than command-line arguments but **higher than application.yml**.  
✅ Allows configurations to be **injected into JVM runtime**.

**Precedence Rule:**  
If **both command-line arguments and JVM system properties** define the same property, **command-line arguments take priority**.

#### **3️⃣ Environment Variables (Universal Approach)**

Environment variables are **universally supported** across all programming languages and platforms, making them a widely used method for external configurations.

##### **Syntax:**

✅ **Windows (Command Prompt)**

```cmd
set SPRING_PROFILES_ACTIVE=prod
java -jar myapp.jar
```

✅ **Linux/macOS (Terminal) or if using GitBash in Windows**

```bash
export SPRING_PROFILES_ACTIVE=qa
java -jar myapp.jar
```

Example:-
```bash
export BUILD_VERSION=8.7
java -jar target/accounts-0.0.1-SNAPSHOT.jar
```

##### **Key Points:**

✅ **Widely supported across all platforms.**  
✅ **No dependency on Java or Spring Boot.**  
✅ Can be **retrieved programmatically** in Java using `System.getenv("SPRING_PROFILES_ACTIVE")`.

🚀 **Conversion Rules for Environment Variables:**  
When setting Spring Boot properties as environment variables:  
1️⃣ Convert **property keys to uppercase**.  
2️⃣ Replace **dots (.) with underscores (\_)**.

✅ **Example:**  
| Property in `application.yml` | Equivalent Environment Variable |
|----------------------------|----------------------------|
| `build.version=1.0.0` | `BUILD_VERSION=1.0.0` |
| `server.port=8080` | `SERVER_PORT=8080` |

### **Comparison of External Configuration Approaches**

| Approach                   | Priority       | Example Syntax                      |
| -------------------------- | -------------- | ----------------------------------- |
| **Command-Line Arguments** | 🔴 **Highest** | `--spring.profiles.active=prod`     |
| **JVM System Properties**  | 🟡 Medium      | `-Dspring.profiles.active=qa`       |
| **Environment Variables**  | 🟢 Lower       | `export SPRING_PROFILES_ACTIVE=dev` |
| **application.yml**        | ⚪ **Lowest**  | `spring.profiles.active=qa`         |

#### **Best Practices for Externalized Configurations**

✔ **Use command-line arguments** when deploying in **containerized environments (Docker, Kubernetes)**.  
✔ **Use environment variables** for cloud-native and **platform-independent configurations**.  
✔ **Use JVM system properties** when running in **traditional on-premise applications**.  
✔ **NEVER hardcode sensitive credentials** inside the codebase—use a **configuration management system** like Spring Cloud Config.

Spring Boot provides **flexible options** to externalize configurations, ensuring that applications remain **portable, scalable, and environment-agnostic**.

---

## 5. Limitations of Externalizing Configurations with Spring Boot

When working with Spring Boot to externalize configurations, there are several challenges that developers may encounter. Although Spring Boot offers various ways to manage configurations—such as using CLI arguments, JVM properties, and environment variables—these approaches have their drawbacks. Below are some of the key limitations:

### a. Manual Setup and Potential Errors
Externalizing configurations using CLI arguments, JVM properties, or environment variables can be effective, especially when you want to maintain the immutability of your application build. However, these methods often require manual intervention for setting up configurations, such as injecting values into CI/CD pipelines or starting the application with specific commands. This introduces the risk of human errors during deployment, and as the number of instances or microservices grows, maintaining consistency across all instances becomes increasingly challenging.

### b. Lack of Centralized Management for Configurations
As applications scale and you manage hundreds of microservices, you’ll likely encounter thousands of configuration properties that change frequently. Without proper versioning, auditing, and centralized management, maintaining these configurations becomes cumbersome. With Spring Boot profiles alone, configurations are typically stored within the source code, making them easily accessible to anyone with access to the code or Docker image. This approach lacks the ability to track changes or control who has access to sensitive configurations.

### c. Security Concerns with Sensitive Data
When externalizing configurations, particularly sensitive data like database credentials, it’s common to use environment variables. However, this presents a security issue because anyone with access to the production server—such as system administrators—can view these environment variables. This exposure of sensitive information can be a serious security risk, especially in large-scale applications where many individuals may have access to the server.

### d. Scalability Issues in Large Microservice Architectures
In a microservices architecture, it’s common to deploy multiple instances of each service. For instance, if you have three microservices, and each microservice has three instances, you end up managing nine instances in total. When scaling this architecture to hundreds of microservices, each with multiple instances, manually configuring each instance becomes unsustainable. The complexity of managing configurations across all instances grows exponentially, making the traditional methods impractical for large-scale applications.

### e. Lack of Encryption and Secure Storage for Secrets
When providing sensitive information—such as database passwords—to a Spring Boot container, the traditional methods like CLI arguments, environment variables, or profiles all require storing these secrets in plain text. These approaches lack encryption or secure storage mechanisms, putting your sensitive data at risk.

### f. Need for Application Restart to Change Configurations
One of the biggest drawbacks of using Spring Boot alone to manage configurations is that changes to configuration properties often require restarting the application or microservice. This is especially problematic in production environments, where a restart can lead to downtime. Ideally, microservices should be able to read the latest property values without needing to restart, but this is not possible with Spring Boot configurations alone.

**Conclusion**
Given these limitations, relying solely on Spring Boot for managing configurations in microservices architectures is not advisable for most applications. While it may work for smaller projects with limited complexity, larger applications with many microservices and frequent configuration changes require a more advanced solution. In the next section, we will explore how Spring Cloud Config Server can address these challenges and provide a more robust and scalable configuration management solution.

---

## 6. Managing Configurations in Microservices with Spring Cloud Config

In the previous section, we explored how configurations can be managed in microservices using Spring Boot. While Spring Boot provides several ways to externalize configurations, relying solely on it presents several limitations. In this section, we'll introduce a more robust and scalable solution: **Spring Cloud Config**.

Spring Cloud Config is a framework within the Spring ecosystem designed to handle configuration management in cloud-native systems, such as microservices. It enables centralized configuration management, making it an ideal solution for large-scale, distributed systems. Let’s dive into how Spring Cloud Config works and why it's a better approach for managing configurations in microservices.

### What is Spring Cloud Config?

Spring Cloud Config offers a centralized configuration server that allows you to store and manage configuration properties for your microservices in a secure and consistent way. Unlike traditional methods that require storing configurations within each microservice or its environment, Spring Cloud Config decouples configuration from the application code, centralizing it in a configuration server.

### Key Components of Spring Cloud Config

Spring Cloud Config revolves around two core components:

1. **Centralized Configuration Repository**: The first step in this approach is storing your configuration properties in a centralized repository. This can be a GitHub repository, a file system, or even a database—whichever suits your project needs. The important aspect is that all configurations are stored in one place, making it easier to manage and scale.

2. **Spring Cloud Config Server**: The centralized configuration server connects to the repository, loads configuration data, and provides it to the microservices when needed. This server manages the configuration properties for all microservices and environments, ensuring consistency and reducing errors.

### How Does Spring Cloud Config Work?

Here’s a step-by-step overview of how Spring Cloud Config operates:

- **Store Configuration Data**: All configuration properties are stored in a centralized repository (e.g., a GitHub repo or file system).
- **Configure the Config Server**: Set up a Spring Cloud Config server that connects to the repository to load configuration properties.
- **Microservices as Config Clients**: Each microservice, whether it’s the accounts service, loans service, or any other, acts as a **config client**. During startup, microservices connect to the config server and fetch their configuration data based on their active profiles.

This process decouples configuration management from your microservices, simplifying the process of managing configurations across various environments.

### Benefits of Spring Cloud Config

Using Spring Cloud Config offers several key advantages over traditional configuration management approaches:

- **Centralized Management**: All configurations are stored in one location, making it easy to manage and maintain.
- **Consistency Across Environments**: The centralized configuration server ensures that all microservices use consistent configuration properties across different environments (development, staging, production).
- **Scalability**: As your microservices architecture grows, the centralized config server can manage configurations for hundreds or thousands of services, eliminating manual configuration handling.
- **Security**: Sensitive configuration data, such as database credentials, can be securely stored and managed, reducing the risk of accidental exposure.

### Spring Cloud Ecosystem

Spring Cloud is not limited to just configuration management. It provides a suite of projects designed to solve common challenges in cloud-native applications and microservices architectures. Some of the most popular Spring Cloud projects include:

- **Spring Cloud Config**: For centralized configuration management
- **Service Registration and Discovery**: Tools like Eureka, Consul, and Zookeeper to register and discover services dynamically
- **Routing and Tracing**: For routing requests and tracing system interactions
- **Load Balancing**: Tools like Ribbon and Spring Cloud Load Balancer for distributing traffic across services
- **Security**: Spring Cloud Security for securing microservices
- **Distributed Tracing and Messaging**: For tracking requests across multiple services and handling messaging patterns

While this guide focuses on Spring Cloud Config, these other projects within the Spring Cloud ecosystem help address additional challenges like service discovery, load balancing, and security. By leveraging the full Spring Cloud suite, developers can build highly scalable, secure, and resilient microservices architectures.

---

## 7. Setting Up Spring Cloud Config Server for Microservices

In this section, we’ll set up a **Spring Cloud Config Server** to manage configurations for our microservices. Currently, the microservices (Accounts, Cards, and Loans) use Spring Boot for configuration management. We’ll now move to a more advanced, centralized configuration approach with **Spring Cloud Config**.

**Setting Up the Project**

1. **Create a New Folder**:  
   Create a new folder named `v2-spring-cloud-config` to house the updated version of the microservices using Spring Cloud Config, keeping both configurations for reference.

2. **Generate Config Server**:  
   Use [Spring Initializr](https://start.spring.io/) to generate a new project for the **Config Server** with the following settings:
  - **Group**: `com.knowprogram`
  - **Artifact**: `config-server`
  - **Dependencies**: Config Server, Actuator

  There are 2 dependencies related to Spring cloud config: `Config Server` and `Config Client`. The `Config Server` dependency is used to create a centralized configuration server. The `Config Client` dependency is used to fetch configurations from the server.

3. **Download and Open in IntelliJ**:  
   After downloading and extracting the ZIP file, open it in IntelliJ IDEA. You’ll have four projects now: **Accounts**, **Cards**, **Config Server**, and **Loans**.

### Config Server Setup

1. **Enable Config Server**:  
   In the main class of the `config-server` project, add the `@EnableConfigServer` annotation to enable the Config Server functionality.

   ```java
   @SpringBootApplication
   @EnableConfigServer
   public class ConfigServerApplication {
       public static void main(String[] args) {
           SpringApplication.run(ConfigServerApplication.class, args);
       }
   }
   ```

2. **Configure `application.yml`**:  
   Rename `application.properties` to `application.yml` and set the port to 8071:

   ```yaml
   server:
     port: 8071
   ```

## 8. Centralizing Configurations

The Config Server can read configurations from various sources:

1. **Classpath**: Store configuration files inside the classpath.
2. **File System**: Store configurations in a folder on the local system or server.
3. **GitHub**: Store configurations in a GitHub repository, allowing version control and collaboration.

We’ll cover all three approaches, starting with storing configurations on the classpath, then moving to the file system and GitHub.

---

### **8.a. Classpath Configuration**

#### Step 1: Set Up Config Server

1. **Define Application Name**:  
   Inside `application.yml` of the config server, define the `spring.application.name` property to set the name of the config server.

   ```yaml
   spring:
     application:
       name: configserver 
       # same name will be used in client applications
       # Name should not have hypens. 
       #Example: `config-server` is invalid.
   ```

#### Step 2: Organize Configuration Files

1. **Create Config Folder**:  
   Under the `resources` folder, create a new `config` folder where all the microservice configurations will reside.

2. **Move Microservice Configurations**:  
   Copy the configuration files for the **Accounts** microservice into the `config` folder (with different profiles: `prod`, `qa`, `default`). Rename these files to reflect the microservice name, such as `accounts.yml`, `accounts-prod.yml`, and `accounts-qa.yml`.

3. **Clean Up Unnecessary Properties**:  
   Remove unnecessary properties that are specific to Spring Boot (e.g., `server.port`, database configurations), leaving only microservice-specific properties.

4. **Repeat for Other Microservices**:  
   Similarly, create configuration files for **Cards** and **Loans** microservices, following the same naming convention.

```
resources/
└── application.yml
└── config/
    ├── accounts.yml
    ├── accounts-prod.yml
    ├── accounts-qa.yml
    ├── cards.yml
    ├── cards-prod.yml
    ├── cards-qa.yml
    ├── loans.yml
    ├── loans-prod.yml
    └── loans-qa.yml
```

#### Step 3: Update Config Server's `application.yml`

1. **Activate Native Profile**:  
   To use **classpath-based configurations**, set the active profile to **`native`**:

   ```yaml
   spring:
     profiles:
       active: native # to read from classpath or filesystem
   ```

2. **Configure Property Search Locations**:  
   Define the location of the configuration files inside the classpath.

   ```yaml
   spring:
     cloud:
       config:
         server:
           native:
             search-locations: classpath:/config
   ```

#### Step 4: Build and Start the Config Server

1. **Build and Run the Server**:  
   Once all configurations are in place, build the project and start the config server on port `8071`. You can check if it’s working by accessing specific profiles for each microservice, e.g., `localhost:8071/accounts/prod` for the `prod` profile of the **Accounts** microservice, `localhost:8071/accounts/qa` for the `qa` profile, `localhost:8071/accounts/default` for the default one.

2. **Validate Profiles**:  
   You should now be able to access different profiles for **Accounts**, **Cards**, and **Loans** microservices via the config server API.

Example response of `http://localhost:8071/cards/qa`:-
```
{
  "name": "cards",
  "profiles": [
    "qa"
  ],
  "label": null,
  "version": null,
  "state": null,
  "propertySources": [
    {
      "name": "classpath:/config/cards-qa.yml",
      "source": {
        "build.version": "2.0",
        "cards.message": "Welcome to PeopleBank cards related QA APIs ",
        "cards.contactDetails.name": "Rocco Jerry - QA Lead",
        "cards.contactDetails.email": "jerryl@peoplebank.com",
        "cards.onCallSupport[0]": "(310) 875-4367",
        "cards.onCallSupport[1]": "(201) 236-1267"
      }
    },
    {
      "name": "classpath:/config/cards.yml",
      "source": {
        "build.version": "3.0",
        "cards.message": "Welcome to PeopleBank cards related local APIs ",
        "cards.contactDetails.name": "Know Program Lech - Developer",
        "cards.contactDetails.email": "dragos@peoplebank.com",
        "cards.onCallSupport[0]": "(412) 419-3491",
        "cards.onCallSupport[1]": "(915) 382-1932"
      }
    }
  ]
}
```

Now let us see how we can use these properties inside accounts, loans, and cards microservices.

#### Step 5: Add Config Client Dependency

Modify the accounts microservice, pom.xml file to include the config-client dependency:-

```xml
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-config</artifactId>
</dependency>
```

Spring cloud version:-

```xml
<properties>
  <java.version>17</java.version>
  <spring-cloud.version>2024.0.1</spring-cloud.version>
</properties>
```

Dependency Management:-

```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-dependencies</artifactId>
      <version>${spring-cloud.version}</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
```
In accounts, application.yml file, add the config-server details:-

```yaml
spring:
  profiles:
    active: prod
  # config server details
  config:
    # config server url (same name and url)
    import: "optional:configserver:http://localhost:8071/"
```

Now, run the accounts microservice, it should work as expected.

---

### **8.b. File System Configuration**

**Storing Configurations in a File System for Spring Cloud Config Server**

In some projects, configurations are stored in a file system location. This approach enhances security by restricting access to only the config server application.  

To achieve this, copy the configurations in a local folder. In the **Spring Cloud Config Server**, update the `application.yml` file:  

- Change `spring.cloud.config.server.native.search-locations` from `classpath` to `file:///{path_to_config_folder}`.  
- For macOS/Linux: `file:///Users/program/Documents/config/`  
- For Windows: `file:///C:/config/`. 

Example in Windows:- `search-locations: file:///C:/workspace/microservices/doc/config`  

After this change, restart the config server and all microservices. Testing the microservices confirms that the configurations load successfully from the file system. The **Spring profile must be set to `native`** in the config server for this to work.

---

### **8.c.1. Storing Configuration Properties in a GitHub Repository**

Let's explore how to store all configuration properties inside a GitHub repository and use it as a source for our Spring Cloud Config Server. This is the most recommended approach due to its multiple advantages, such as security, versioning, and auditing. 

#### Why Use GitHub for Configuration Management?
Using GitHub to manage configuration properties offers several benefits:
- **Security:** You can restrict access to your repository.
- **Versioning & Auditing:** You can track historical changes to configurations.
- **Scalability:** Multiple microservices can pull configurations from a central repository.

#### Setting Up GitHub as a Config Source
To get started, follow these steps:

1. **Move Configuration Files to GitHub:**  
   Create a GitHub repository (e.g., `peoplebank-config`) and upload configuration files for microservices like `accounts`, `loans`, and `cards`.

2. **Modify the Config Server `application.yml`:**  
   Update the configuration to use GitHub as a backend:
   ```yaml
   spring:
     profiles:
       active: git
     cloud:
       config:
         server:
           git:
             uri: https://github.com/yourusername/peoplebank-config
             default-label: main
             timeout: 5
             clone-on-start: true
             force-pull: true
   ```
   - `active: git` enables the GitHub-based approach.
   - `uri` specifies the repository URL.
   - `default-label` sets the branch to pull from (branch name).
   - `timeout` ensures quick failure if GitHub is unreachable.
   - `clone-on-start` clones the repository during startup.
   - `force-pull` ensures the latest changes are always fetched.

3. **Start the Config Server and Microservices:**
   - Start the Spring Cloud Config Server.
   - Verify it connects to GitHub by checking the logs.
   - Access `http://localhost:8071/accounts/prod` to check if configurations are loaded from GitHub.
   - Start microservices (`accounts`, `loans`, `cards`) and validate they fetch properties from the config server.

#### Using a Private GitHub Repository
For private repositories, authentication is required. You can:
- Use **username and password** authentication.
- Configure **SSH-based access**.
- Follow the Spring Cloud Config documentation for additional security settings.

#### Alternative Backends
Spring Cloud Config supports multiple backends:
- **File System Backend:** Stores properties locally.
- **Vault & AWS Secret Manager:** Securely manage secrets.
- **JDBC Backend:** Store configurations in a database.

For more details, refer to the [Spring Cloud Config documentation](https://spring.io/projects/spring-cloud-config).

---

### 8.c.2. Encrypting Configuration Properties in Spring Cloud Config Server

Now that we have successfully stored our configuration properties in a GitHub repository, it's time to enhance security by encrypting sensitive data. By default, all properties in GitHub are stored in **plain text**, which poses a security risk. To protect sensitive details such as passwords, API keys, and database credentials, we can **encrypt configuration properties** using **Spring Cloud Config Server**.

#### Why Encrypt Configuration Properties?
- **Enhanced Security:** Prevent unauthorized access to sensitive information.
- **Safe Storage:** Even if someone gains access to the GitHub repo, they won't be able to read sensitive data.
- **Secure Communication:** Microservices can still receive decrypted values dynamically from the Config Server.

### Configuring Encryption in Spring Cloud Config Server

#### 1. Define an Encryption Key
To enable encryption, we need to define a **secret key** inside the `application.yml` of the Config Server.

```yaml
encrypt:
  key: aVeryComplexAndRandomSecretKey12345!
```
> **Note:** Choose a **strong secret key** to prevent brute-force attacks. You can generate random keys using online tools or CLI utilities.

#### 2. Restart the Config Server
After adding the encryption key, restart the Config Server to apply changes.

### Encrypting Sensitive Properties

#### 1. Use the `/encrypt` API
Spring Cloud Config Server exposes an **encryption API** to encode plaintext values. To encrypt a value:
- Send a **POST** request to:
  ```
  POST http://localhost:8071/encrypt
  ```
- In the request body, provide the plain text value you want to encrypt.

Example:
```
test-email@example.com
```

- The response will return an **encrypted value**, such as:
  ```
  c13c6758fd5a7c1230d9a7b26f1f8a74b9c5e...
  ```

#### 2. Store the Encrypted Value in GitHub
Once encrypted, update the **configuration file** inside the GitHub repository with the encrypted value:

```yaml
contactDetails:
  email: "{cipher}c13c6758fd5a7c1230d9a7b26f1f8a74b9c5e..."
```

> **Important:**  
- Always prefix **encrypted values** with `{cipher}` so that Spring Cloud Config Server knows they are encrypted.

#### 3. Restart the Config Server
Restart the Config Server to ensure it fetches the updated encrypted configuration.

### Decrypting Configuration Properties

#### 1. Verify Decryption Using `/decrypt` API
To verify decryption, send a **POST** request to:

```
POST http://localhost:8071/decrypt
```

- Provide the encrypted value in the request body.
- The response should return the original plain text value.

#### 2. Validate Config Server Decryption
- Start the **Config Server** and invoke:
  ```
  GET http://localhost:8071/accounts/prod
  ```
- The response should return **decrypted** property values.
- Start the **Accounts Microservice** and invoke:
  ```
  GET http://localhost:9000/accounts/contact-info
  ```
- The microservice should receive decrypted properties.

### Securing the Config Server in Production
In production environments:
- **Do not expose encryption APIs (`/encrypt` & `/decrypt`) publicly.**  
- **Deploy Config Server behind a firewall.**  
- **Use environment variables or CLI arguments** instead of hardcoding the encryption key in `application.yml`.  
- **Enable Spring Security** to restrict access to configuration endpoints.

---

## 9. Dynamically Refreshing Configuration Properties in Microservices  

In a microservices environment, managing configuration properties efficiently is crucial. While **Spring Cloud Config Server** allows us to centralize configurations, a common challenge arises when we need to update properties **at runtime without restarting** microservices. Restarting microservices manually can be impractical, especially in large-scale systems with **hundreds of microservices and multiple instances**.  

**The Need for Dynamic Configuration Refresh**

Imagine a scenario where you have a **feature flag** in your configuration that controls a specific business logic inside a microservice. If you need to update the flag value, you want the change to reflect **immediately** across all instances without restarting the services. Restarting services for configuration updates can:  
- Be **manual and time-consuming**  
- Affect **application availability and traffic**  
- Be **unscalable** in large environments  

### Enabling Runtime Configuration Refresh  

To dynamically refresh configurations, we leverage **Spring Boot Actuator** and its `/refresh` endpoint. This allows microservices to reload updated configurations **without restarting**.  

#### **Step 1: Add Actuator Dependency**  

Ensure that each microservice has the Spring Boot Actuator dependency in `pom.xml`:  

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```  

#### **Step 2: Convert Record Classes to Mutable Classes**  

By default, Java **record classes** create immutable objects, preventing property updates at runtime. We need to replace **record classes** with regular Java classes using **Lombok** to allow property changes.  

Example update for `AccountsContactInfoDto`:  

```java
@Getter
@Setter
@Component
@ConfigurationProperties(prefix = "accounts")
public class AccountsContactInfoDto {
    private String message;
    private Map<String, String> contactDetails;
    private List<String> onCallSupport;
}
```  

Repeat this update for similar DTOs in other microservices like **Loans** and **Cards**.  

#### **Step 3: Enable Refresh Endpoint in `application.yml`**  

By default, Spring Boot does not expose the `/refresh` endpoint. Enable it by adding the following property inside each microservice’s `application.yml`:  

```yaml
management:
  endpoints:
    web:
      exposure:
        include: refresh
```
Alternatively, to expose **all** Actuator endpoints, use:  
```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

#### **Step 4: Start Microservices and Validate Initial Configurations**  

1. Build and start the **Config Server**.  
2. Start microservices: **Accounts, Loans, and Cards**.  
3. Check that microservices are fetching configurations correctly from the Config Server.  

#### **Step 5: Update Configuration in GitHub**  

- Modify a property inside the **GitHub repository** (e.g., update `message` property in `accounts-prod.yml`).  
- Commit the changes directly to GitHub.  

#### **Step 6: Verify Config Server Fetches Latest Configurations**  

Check if the **Config Server** retrieves the updated configuration:  
```bash
GET http://localhost:8071/accounts/prod
```
The response should reflect the latest values from GitHub.  

#### **Step 7: Manually Refresh Microservices**  

By default, microservices do **not** automatically reload the new configuration. To force an update **without restarting**, we must invoke the **Actuator `/refresh` API** for each microservice.  

Use **Postman** or **cURL**:  

```bash
POST http://localhost:8080/actuator/refresh
```

Repeat this step for **all microservices** (Loans, Cards). Once done, test the microservices again:  
```bash
GET http://localhost:8080/accounts/contact-info
```
The updated value should now be visible.

![Actuator Refresh](images/actuator-refresh.png)

### **Drawback of the Manual Refresh Approach**  

While the `/refresh` API helps avoid restarts, it presents a **scalability issue** in large systems:  

- If you have **100 microservices** with **5 instances each**, you must manually invoke `/refresh` on **500 instances**.  
- Automating the refresh process with **CI/CD scripts** or **Jenkins jobs** is possible but **not always ideal**.  

**What’s Next? Automating Configuration Refresh**  

Instead of manually invoking `/refresh` for each microservice, we need a **more efficient** approach. In the next section, we will explore how to **automatically refresh configurations across all microservices** using **Spring Cloud Bus** and **message brokers like RabbitMQ or Kafka**.  

By implementing **Spring Cloud Bus**, we can broadcast configuration changes to all microservices dynamically, eliminating the need to manually call the `/refresh` API. 

---

## 10. Spring Cloud Bus: Automating Configuration Refresh Across Microservices

In this section, we will explore how to **automatically refresh configurations across all microservices** using **Spring Cloud Bus** and **message brokers like RabbitMQ or Kafka**.  Spring Cloud Bus allows us to broadcast configuration changes across all instances with a single API call.  

### How Spring Cloud Bus Works  

1. **Interlinking Services:** Spring Cloud Bus connects all microservices to a central message broker.  
2. **Single Refresh Invocation:** Instead of calling the refresh API on each instance, we only need to invoke the **Bus Refresh API** on one instance.  
3. **Automated Propagation:** The message broker propagates configuration changes to all registered microservices, eliminating the need for multiple manual refreshes.  

### Setting Up Spring Cloud Bus  

#### 1. Install and Configure RabbitMQ  
To enable Spring Cloud Bus, we first need a message broker. [RabbitMQ](https://www.rabbitmq.com/docs/download) is a popular choice, and it can be set up quickly using Docker:  

```bash
docker run -d -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4.0-management
```

This command pulls and runs RabbitMQ in a Docker container with a management UI. Now, you can access RabbitMQ UI at `http://localhost:15672`.


#### 2. Add Dependencies  
We need to add the **Spring Cloud Bus AMQP** dependency in the `pom.xml` of all microservices and the Config Server:  

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>
```

#### 3. Enable Actuator Endpoints  
To allow runtime refresh, update `application.yml` in each microservice (not required in the Config Server) to expose the actuator endpoints:  

```yaml
management:
  endpoints:
    web:
      exposure:
        include: "bus-refresh"
```

If you have already specified `include: "*"` then you don't need to add `bus-refresh` separately.

#### 4. Configure RabbitMQ Connection  
Each microservice must specify RabbitMQ connection details in `application.yml`:  

```yaml
spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
```
Here the `localhost`, `5672`, `guest`, and `guest` are default RabbitMQ settings. Therefore if we don't include these details, the microservices will be able to detect it by default. But if we are using custom port-number, username, password, host and e.t.c then we must specify it.

Now, start the config server and then all the microservices.

#### 5. Propagating Configuration Changes  
Once all microservices are configured, follow these steps to apply changes dynamically:  

1. Modify configuration files in the **Config Server's Git repository**.  
2. Invoke the **Bus Refresh API** on **any microservice**, it will give 204 response code (doesn't return any content):  

   ```sh
   curl -X POST http://localhost:<port>/actuator/busrefresh
   ```

3. Spring Cloud Bus will notify all microservices, refreshing their configurations **without restarts**.  

![Spring Cloud Bus with RabbitMQ](images/spring-cloud-bus-with-rabbitmq.png)

### Advantages and Considerations  

✅ **Efficient Configuration Propagation:** One API call updates all microservices.  
✅ **No Restarts Needed:** Changes apply instantly without downtime.  
✅ **Scalable for Large Deployments:** Works seamlessly even with hundreds of instances.  

However, **manual intervention is required** to trigger the busrefresh API at least once. If configuration updates are frequent, consider automating this step through a CI/CD pipeline.  

In the next section, we will explore strategies to fully automate this process and eliminate manual refresh invocations. Stay tuned!

---

## 11. Automating Property Refresh in Microservices with Spring Cloud Config Monitor and GitHub Webhooks

In our microservices network, we currently refresh properties at runtime without restarting service instances by manually invoking the bus refresh or refresh APIs within the actuator. However, both of these methods require manual intervention, meaning someone needs to trigger either the bus refresh on one instance or the refresh API on all microservices. 

In this section, we’ll explore an automated approach to refresh properties without manually invoking any API path. This new approach leverages GitHub webhooks built on top of the Spring Cloud Bus, which we previously discussed. The key idea is that changes in the GitHub repository, such as property additions, will automatically trigger property refreshes in the microservices network.

To get started, we need to make some updates to the config server and its associated microservices.

### Steps to Set Up the Automated Property Refresh

1. **Add the Spring Cloud Config Monitor Dependency in config server**:
   First, we need to add the **Spring Cloud Config Monitor** dependency to the **pom.xml** file of the **config server**. This dependency is required only in the config server, not in the other microservices. By adding this, the Spring Cloud Config Server will expose a new REST API endpoint called `/monitor`. This API is not part of the actuator, but is exposed specifically by the Spring Cloud Config Server.

   ```xml
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-config-monitor</artifactId>
    </dependency> 
   ```

   Using the `/monitor` API exposed by the config server, we can create a webhook in GitHub. This webhook will trigger the `/monitor` endpoint whenever a change occurs in the GitHub repository (such as adding or modifying a property). Upon receiving the webhook request, the config server will invoke a refresh event using the Spring Cloud Bus, along with RabbitMQ, to refresh the properties in the microservices.

2. **Update `application.yaml` in Config Server**:
   Next, we need to update the `application.yaml` file in the config server to include the property `management.endpoints.web.exposure.include` set to `*`. This step ensures that all management endpoints, including those required for triggering the bus refresh, are enabled in the config server.

   ```yaml
   management:
    endpoints:
      web:
        exposure:
          include: "*"
   ```

3. **Configure RabbitMQ (Optional but Recommended)**:
   To maintain consistency, you may want to specify RabbitMQ connection details in the config server’s `application.yaml` file. While RabbitMQ configuration is optional, it's a good practice to ensure consistency with other microservices in the network. You can add the host, port, username, and password for RabbitMQ in the config server configuration.

    ```yaml
    spring:
      rabbitmq:
        host: localhost
        port: 5672
        username: guest
        password: guest
    ```

4. **Create a Webhook in GitHub**:
   After configuring the necessary settings in the config server, the next step is to create a webhook in your GitHub repository. This webhook will send a POST request to the `/monitor` endpoint of the config server whenever changes are made in the repository. 

   - **Payload URL**: The URL where the webhook request will be sent is `http://localhost:8071/monitor`. However, GitHub cannot send a request to a `localhost` address, so we will use a tool to expose this local address externally (as explained below).
   - **Content Type**: Set the content type to `application/json`.
   - **Event Trigger**: The webhook should be triggered only on a **push event**, meaning changes to the repository (commits) will automatically initiate the refresh.

5. **Using Hookdeck for Local Testing**:
   Since GitHub cannot send webhook requests to a `localhost` URL, we can use **[Hookdeck](https://console.hookdeck.com/)** (or similar services) to expose our local server to the internet. Hookdeck acts as a bridge, allowing GitHub to send the webhook request to a public URL, which will then be redirected to the local system. 

   To set this up, you will:
   - Go to [Hookdock Console](https://console.hookdeck.com/), Click on add destination => Localhost => set URL path as /monitor.
   - Install the **Hookdeck** CLI tool and authenticate it on your local system.
   - Use the `hookdeck listen` command to specify the local port and endpoint (`/monitor`), so the service listens for requests.
   
    ```
    hookdeck listen [port] Source
    ```
    Use config-server port 8071:- `hookdeck listen 8071 Source`.

   - After setting it up, Hookdeck will provide a public URL (Example:- `https://hkdk.events/cu11za841rozk9`), which you can configure as the payload URL in your GitHub webhook settings.

6. Configure GitHub Webhooks:- In the config-server repo, go to the settings => Webhooks => add Payload URL. The content-type should be `application/json`. For the question:- `Which events would you like to tigger this webhook?` use:- `Just the push event`. Add the webhook.

6. **Verify the Setup**:
   Once everything is configured, you can test the automated property refresh by making changes to your GitHub repository. When you modify a file (e.g., `cards-prod.yaml`), the webhook will be triggered automatically, and the Spring Cloud Config Server will refresh the properties across the microservices.

![GitHub WebHook](images/github-webhook.png)

By following these steps, you can automate the refresh of properties in your microservices network without manual intervention. This setup is highly useful for production scenarios, where you need to ensure configuration updates happen seamlessly and efficiently.

In the next section, we will explore converting our microservices into Docker images and deploying them using Docker Compose.

---

## 12. Containerizing Microservices with Docker Compose

As of now, with the help of the config server and other microservices instances, we have successfully tested all configuration management-related changes within our local system. However, the next step in our journey is to containerize all our microservices applications, including the config server. Once containerized, we will use Docker Compose to start all our microservices along with the config server in a seamless manner.

### Why Containerization is Important

The reason we are putting effort into running our configuration changes inside a Docker environment is that, ultimately, we will deploy our microservices into production environments such as Kubernetes clusters. Docker containers provide a consistent and portable runtime environment, ensuring that our applications run the same way across different systems.

### Setting Up Docker Compose for Different Environments

Instead of using a single Docker Compose file, we will create separate files for different environments: **default, QA, and production (prod)**. This approach allows greater flexibility when making environment-specific configurations.

To organize our setup:
1. We will create a new directory named **docker-compose** inside the project.
2. Inside this directory, we will create three subdirectories: **default, QA, and prod**.
3. Each of these directories will contain a dedicated `docker-compose.yml` file.

### Moving and Updating Docker Compose Files

Previously, we had a `docker-compose.yml` file inside the `accounts` microservice. We will now move this file into the **default** environment and delete it from `accounts`, as we no longer need it there.

Upon opening the `docker-compose.yml` file, we can see that it includes configurations for **accounts, loans, and cards** microservices. We will update the **image names** to include a version-specific tag (e.g., `S6` for Section 6 of our development process).

Additionally, we will add a new service for the **config server** inside the Docker Compose file. This service will have the following settings:
```yaml
    configserver:
        image: vikas9dev/configserver:s6
        container_name: configserver
        ports:
            - "8071:8071"
        deploy:
            resources:
                limits:
                    memory: 700M
        networks:
            - PeopleBank
```

### Connecting Microservices to the Config Server

Each microservice needs to connect with the config server inside the Docker environment. In the `application.yml` files of microservices, we define the configuration import using:

```
spring.config.import=http://localhost:8071
```

However, inside Docker containers, **localhost cannot be used** because each microservice runs in an isolated network. Instead, we must use the **config server’s service name** to ensure proper communication. To achieve this, we will define environment variables inside `docker-compose.yml`:

- **`SPRING_CONFIG_IMPORT`**: `http://configserver:8071`
- **`SPRING_PROFILES_ACTIVE`**: This specifies the environment profile (e.g., `default`, `QA`, or `prod`).
- **`SPRING_APPLICATION_NAME`**: This must match the microservice's name as stored in the config server.

```yaml
services:
    configserver:
        # existing details
        environment:
            - SPRING_CONFIG_IMPORT="configserver:http://configserver:8071"
            - SPRING_PROFILES_ACTIVE=default
            - SPRING_APPLICATION_NAME="configserver"
```

Due to a known bug in Spring Cloud Config Server, we must explicitly define `SPRING_APPLICATION_NAME` inside `docker-compose.yml`, even if it matches the name inside `application.yml`.

### Ensuring Config Server Starts Before Other Microservices

A challenge with Docker Compose is that it does not wait for one service to be fully operational before starting others. If microservices start before the config server is ready, they may fail due to missing configuration.

To solve this, we need to use **liveness and readiness probes** to ensure that:
- The **config server** is fully started before any microservice attempts to connect.
- Microservices **wait for the config server** before starting.

We will explore these concepts in detail in the next section.

Stay tuned as we dive deeper into **liveness and readiness probes** to optimize our Docker Compose setup for smooth microservices deployment!

---

## 13. Understanding Liveness and Readiness Probes in Microservices  

When deploying microservices or any cloud-native application, we typically use **Docker containers**. These containers need to be monitored and managed efficiently, and this is where **container orchestration platforms** like **Kubernetes** come into play.  

To ensure the health and availability of running containers, Kubernetes (or even Docker) uses **liveness** and **readiness probes**. These probes help detect issues, restart failing containers, and ensure that only fully initialized services receive traffic.  

### What is Liveness?  

The **liveness probe** determines if a container is still running properly. Kubernetes periodically checks this probe to answer a simple **true or false** question:  

> **Is this container alive?**  

- If the container is **alive**, no action is needed.  
- If the container is **dead**, Kubernetes will attempt to restart it. If restarts fail, Kubernetes may replace the container entirely.  

#### Real-World Analogy:  

Think of a **boxer before a fight**. If the boxer is sitting in the ring, taking water or warming up, he is **alive**, but he may not yet be ready to fight. This represents **liveness**—the system is running, but not necessarily prepared to handle requests.  

### What is Readiness?  

The **readiness probe** ensures that a container is ready to **accept network traffic**. A container might be alive but still initializing—perhaps it's:  

- Connecting to a database  
- Loading configuration files  
- Performing background tasks  

Kubernetes waits for the **readiness probe** to return a positive response before routing traffic to the container. This prevents requests from failing due to incomplete initialization.  

#### Real-World Analogy:  

Continuing with our boxing example, when the boxer **stands in the center of the ring, gloves on, ready to fight**, he is both **alive and ready**. That’s when the match begins—just as Kubernetes will only send traffic to a service that is fully ready.  

### Implementing Liveness and Readiness in Spring Boot  

Spring Boot simplifies health monitoring with **Spring Actuator**. By enabling actuator endpoints, we can check both liveness and readiness using:  

- `/actuator/health/liveness`  
- `/actuator/health/readiness`  

To enable these probes, update the **`application.yml`** of your Spring Boot **Config Server**:  

```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
  # add below properties
  health:
    readiness-state:
      enabled: true
    liveness-state:
      enabled: true
  endpoint:
    health:
      probes:
        enabled: true
```

With these configurations, Kubernetes (or any orchestrator) can determine when the Config Server is both **alive and ready** before starting dependent services like **Accounts, Loans, and Cards microservices**.  

### Testing Liveness and Readiness Locally  

1. **Start the Config Server**  
2. Access `http://localhost:8071/actuator/health`  
3. If dependencies (like RabbitMQ) are missing, the status may be **DOWN**  
4. Once all dependencies are available, recheck the endpoint—it should return **UP**  
5. Check specific probes:  
   - `http://localhost:8071/actuator/health/liveness`  
   - `http://localhost:8071/actuator/health/readiness`  

---

Here's how you can structure this as an H2 section for a blog post:  

---

## 14. Enhancing Docker Compose with Health Checks and Dependencies  

Now that our **Config Server** is exposing **liveness** and **readiness** information using **Spring Boot Actuator**, the next step is to integrate these health checks into **Docker Compose**. This ensures that our microservices start in the correct order and only when they are fully ready.  

### Adding a Health Check to the Config Server  

To communicate with **Docker or Docker Compose** about the health status of our **Config Server**, we need to define a **healthcheck** section inside the `docker-compose.yml` file.  

We'll add the **healthcheck** section right after the `ports` section:  

```yaml
services:
  configserver:
    image: my-config-server:latest
    ports:
      - "8071:8071"
    healthcheck:
      test: "curl --fail --silent localhost:8071/actuator/health/readiness | grep UP || exit 1"
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 10s
```

#### How This Works  

- The **`test`** command runs `curl` to check the `/actuator/health/readiness` endpoint.  
- If the response contains **"UP"**, the health check **passes**. Otherwise, it **fails**.  
- **Retries, timeouts, and intervals** ensure the health check runs at regular intervals and gives the service time to start.  

### Defining Dependencies for Other Microservices  

Our **Accounts, Loans, and Cards microservices** depend on the **Config Server**. However, if we simply add:  

```yaml
depends_on:
  - configserver
```

Docker will only ensure that the **Config Server starts** — it won't wait for it to be fully **healthy**.  

To make sure our microservices wait until the **Config Server is completely started**, we update `depends_on` as follows:  

```yaml
services:
  accounts:
    ports:
      - "8081:8081"
    depends_on:
      configserver:
        condition: service_healthy
    # remaining info
  loans:
    ports:
      - "8082:8082"
    depends_on:
      configserver:
        condition: service_healthy
    # remaining info
  cards:
    ports:
      - "8083:8083"
    depends_on:
      configserver:
        condition: service_healthy
    # remaining info
```

#### Why Use `service_healthy`?  

- The **`service_healthy`** condition ensures that **Accounts, Loans, and Cards services** wait until **Config Server** is **fully up and healthy**.  
- Without this, services might start too early and fail due to missing configurations.  

### Adding RabbitMQ as a Dependency  

Since our **Config Server and microservices use Spring Cloud Bus**, they depend on **RabbitMQ**. We define **RabbitMQ** as a service in `docker-compose.yml`:  

```yaml
services:
  rabbit:
    image: rabbitmq:3.12-management
    hostname: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: rabbitmq-diagnostics check_port_connectivity
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - PeopleBank
```

Then, we update our **Config Server** to depend on RabbitMQ:  

```yaml
services:
  configserver:
    depends_on:
      rabbit:
        condition: service_healthy
```

### Ensuring Network Connectivity  

To ensure all services run in the same **Docker network**, we define a network called `PeopleBank`:  

```yaml
networks:
  PeopleBank:
    driver: bridge
```

Then, we assign this network to all services:  

```yaml
services:
  configserver:
    networks:
      - PeopleBank
  accounts:
    networks:
      - PeopleBank
  loans:
    networks:
      - PeopleBank
  cards:
    networks:
      - PeopleBank
  rabbitmq:
    networks:
      - PeopleBank
```

With these updates:  

1. **RabbitMQ starts first and reaches a healthy state.**  
2. **Config Server starts next and waits for RabbitMQ to be healthy.**  
3. **Accounts, Loans, and Cards microservices start only after Config Server is healthy.**  
4. **All services communicate within the same EasyBank network.**  

---

## 15. Optimizing Docker Compose File

In `common-config.yml`:-

```yaml
services:
  network-deploy-service:
    networks:
      - PeopleBank

  microservice-base-config:
    extends:
      service: network-deploy-service
    deploy:
      resources:
        limits:
          memory: 700m
    environment:
      SPRING_RABBITMQ_HOST: "rabbit"

  microservice-configserver-config:
    extends:
      service: microservice-base-config
    environment:
      SPRING_PROFILES_ACTIVE: default
      SPRING_CONFIG_IMPORT: configserver:http://configserver:8071/
```

In `docker-compose.yml`:-

```YAML
services:
    rabbit:
        image: rabbitmq:3.13-management
        hostname: rabbitmq
        ports:
            - "5672:5672"
            - "15672:15672"
        healthcheck:
            test: rabbitmq-diagnostics check_port_connectivity
            interval: 10s
            timeout: 5s
            retries: 10
            start_period: 5s
        extends:
            file: common-config.yml
            service: network-deploy-service

    configserver:
        image: "vikas9dev/configserver:s6"
        container_name: configserver-ms
        ports:
            - "8071:8071"
        depends_on:
            rabbit:
                condition: service_healthy
        healthcheck:
            test: "curl --fail --silent localhost:8071/actuator/health/readiness | grep UP || exit 1"
            interval: 10s
            timeout: 5s
            retries: 10
            start_period: 10s
        extends:
            file: common-config.yml
            service: microservice-base-config

    accounts:
        image: "vikas9dev/accounts:s6"
        container_name: accounts-ms
        ports:
            - "8080:8080"
        depends_on:
            configserver:
                condition: service_healthy
        environment:
            SPRING_APPLICATION_NAME: "accounts"
        extends:
            file: common-config.yml
            service: microservice-configserver-config

    loans:
        image: "vikas9dev/loans:s6"
        container_name: loans-ms
        ports:
            - "8090:8090"
        depends_on:
            configserver:
                condition: service_healthy
        environment:
            SPRING_APPLICATION_NAME: "loans"
        extends:
            file: common-config.yml
            service: microservice-configserver-config

    cards:
        image: "vikas9dev/cards:s6"
        container_name: cards-ms
        ports:
            - "9000:9000"
        depends_on:
            configserver:
                condition: service_healthy
        environment:
            SPRING_APPLICATION_NAME: "cards"
        extends:
            file: common-config.yml
            service: microservice-configserver-config

networks:
    PeopleBank:
        driver: bridge
```

The configserver microservice does not have jib dependencies, therefore add them:-

```xml
  <build>
		<plugins>
      <plugin>
				<groupId>com.google.cloud.tools</groupId>
				<artifactId>jib-maven-plugin</artifactId>
				<version>3.4.5</version>
				<configuration>
					<to>
						<image>vikas9dev/${project.artifactId}:s6</image>
					</to>
				</configuration>
			</plugin>
    </plugins>
	</build>
```

Let us create the docker image for all the microservices. 

```bash
cd c/workspace/microservices/accounts/
mvn compile jib:dockerBuild
cd ../loans
mvn compile jib:dockerBuild
cd ../cards
mvn compile jib:dockerBuild
cd ../configserver/
mvn compile jib:dockerBuild
docker images
```

Push the images to the Docker Hub:-
```bash
docker image push docker.io/vikas9dev/accounts:s6
docker image push docker.io/vikas9dev/cards:s6
docker image push docker.io/vikas9dev/loans:s6
docker image push docker.io/vikas9dev/configserver:s6
```

Start the containers through docker-compose file:-

```bash
cd ../docker-compose
ll
cd default
docker compose up -d
```
Stop the containers using:-
```
docker compose down
```
For `prod` and `qa` copy the same `common-config.yml` and `docker-compose.yml`. And in the `common-config.yml` modify the active profile details:-

```yaml
services:
  microservice-configserver-config:
    environment:
      SPRING_PROFILES_ACTIVE: qa
```
