# Configurations Management in Microservices

In this section, we will discuss another Challenge, a crucial issue faced while building microservices or cloud-native applications‚Äî**Configuration Management**.

### Understanding the Challenge

One of the key principles of microservices is **separating configuration from business logic**. Unlike monolithic applications, where configurations are tightly coupled with the code, microservices require a different approach.

Here are some critical questions that arise when managing configurations in a microservices architecture:

- **How do we separate configurations from business logic?**

  - If we bundle configurations with the business logic, we must create separate Docker images for each environment. This is inefficient and goes against best practices.
  - The same Docker image should be reusable across all environments.

- **How do we inject configuration at runtime?**

  - Some sensitive configurations, such as credentials, cannot be hardcoded inside the business logic.
  - These must be injected securely at the time of service startup.

- **How do we manage configurations centrally?**
  - In monolithic applications, managing configurations manually may be feasible.
  - However, in microservices, where there could be **hundreds of services**, it becomes challenging to track configurations for each one.
  - A centralized configuration repository with version control is essential.

### Solutions for Configuration Management in Microservices

To tackle these challenges, multiple solutions are available within the **Spring Boot ecosystem**:

1. **Basic Approach:** Configuring Spring Boot with application properties and profiles.
2. **External Configuration Approach:** Storing configurations outside the microservice and injecting them at runtime.
3. **Spring Cloud Config Server:** A dedicated configuration server that manages all microservice configurations centrally.

Throughout this section, we will explore and implement these approaches in our **Accounts, Loans, and Cards** microservices.

### Traditional vs. Modern Configuration Management

**Traditional Applications (Monolithic Architecture)**

- Configurations are bundled with the source code.
- Any change in the configuration requires a rebuild and redeployment.
- There is no guarantee of consistency across environments.

**Microservices-Based Architecture**

- Configurations must be **externalized** from the business logic.
- The same **immutable artifact (Docker image)** is used across all environments.
- Configuration is injected dynamically based on the target environment (Dev, QA, Prod).

### Recommended Approach

Following the **12-Factor App methodology**, configurations that change between deployments (e.g., credentials, URLs) should be **stored separately** and injected at runtime.

The deployment process typically follows this workflow:

1. The **source code** is stored in a **GitHub repository**.
2. The application is **compiled and packaged** into a build (Docker image).
3. The **same build** is used across all environments (Dev, QA, Prod).
4. **Configuration is injected dynamically** at runtime, ensuring flexibility and security.

This approach ensures **consistency** across environments while keeping application artifacts **immutable**.

---

## 2. Basics of Configuration Management in Spring Boot

Since we are building our microservices using **Spring Boot**, it‚Äôs essential to understand how configuration management works within this framework. Spring Boot provides multiple ways to **externalize configurations**, ensuring that the same **immutable code artifact** can be reused across different environments without requiring a rebuild.

In this section, we will explore the **basic configuration approaches** available in Spring Boot before moving to advanced solutions like **Spring Cloud Config Server**.

---

### Why Externalize Configuration?

The **main challenge** in microservices configuration management is separating **business logic from configurations**.

- If **configuration is bundled with the code**, we need to **rebuild the application** for every environment change.
- The **recommended approach** is to keep the **same application build** across all environments and inject configurations dynamically.

Spring Boot allows us to achieve this by **externalizing configurations** using various approaches.

---

### Configuration Sources in Spring Boot

Spring Boot provides **multiple ways** to specify configuration properties:

1. **Property Files & YAML Files** (`application.properties` or `application.yml`)
2. **Environment Variables** (set at the OS level)
3. **Command-Line Arguments** (passed when starting the application)
4. **Java System Properties** (`-Dproperty=value` in JVM options)
5. **Servlet Config & Init Parameters** (for web applications)

By default, Spring Boot looks for **`application.properties`** or **`application.yml`** in the **classpath location**. However, we can override these properties at runtime using **environment variables or command-line arguments**.

---

### Spring Boot Configuration Priority Order

If the **same property** is defined in multiple places, **Spring Boot follows a priority order** when resolving its value:

| Priority        | Configuration Source                                        |
| --------------- | ----------------------------------------------------------- |
| **1** (Highest) | Command-Line Arguments (`--property=value`)                 |
| **2**           | Java System Properties (`-Dproperty=value`)                 |
| **3**           | OS Environment Variables                                    |
| **4**           | `application.properties` / `application.yml` (in classpath) |

**Lower priority sources** (e.g., `application.properties`) can be **overridden** by **higher-priority sources** (e.g., environment variables or command-line arguments).

---

### How to Read Configuration Properties in Spring Boot?

Once the configuration properties are defined, we need **ways to access them** inside our business logic. Here are three commonly used approaches:

#### 1. **Using `@Value` Annotation**

The simplest way to read a single property is by using the `@Value` annotation:

```java
@Value("${server.port}")
private String serverPort;
```

- `server.port` will be **injected** from the property file or environment variables.
- **Limitations**: Requires **hardcoding** property names and is not efficient for multiple properties.

---

#### 2. **Using `Environment` Interface**

For **dynamic configurations**, we can use the `Environment` interface provided by Spring Boot:

```java
@Autowired
private Environment environment; // Import from Spring Boot (not from Hibernate)

@GetMapping("/java-version")
public ResponseEntity<String> getJavaVersion() {
    return ResponseEntity.ok().body(env.getProperty("JAVA_HOME"));
}
```

Another Example:-

```java
@Autowired
private Environment environment;

public String getDatabaseUrl() {
    return environment.getProperty("spring.datasource.url");
}
```

- Useful when configurations come from **environment variables**.
- **More flexible** than `@Value`, but still involves **manual property retrieval**.

---

#### 3. **Using `@ConfigurationProperties`** (Recommended for Multiple Properties)

When working with **multiple related properties**, we should use `@ConfigurationProperties`:

1. **Define properties with a common prefix** in `application.yml`:

```yaml
accounts:
  message: "Accounts Microservice"
  contactDetails:
    name: "Accounts Microservice - Developer"
    email: "0V7ZD@example.com"
  onCallSupport:
    - (555) 555-5555
    - (555) 555-5556
```

2. **Create a Java class to bind properties:**

```java
@Component
@ConfigurationProperties(prefix = "accounts")
@Setter
@Getter
public class AccountsContactDto {
    private String message;
    private Map<String, String> contactDetails;
    private List<String> onCallSupport;
}
```

3. **Inject and use the properties:**

```java
@Autowired
private AccountsContactDto contactDto;

@GetMapping("/contact-info")
public ResponseEntity<AccountsContactDto> getContactDetails() {
    return ResponseEntity.ok().body(contactDto);
}
```

- **Benefits**:  
  ‚úÖ Avoids hardcoding property names  
  ‚úÖ Supports **multiple properties** binding  
  ‚úÖ More **structured** and **scalable**

We can replace the AccountsContactDto class with a Java 17 record type if we prefer. Using Java 17 record instead of a simple class has several advantages, particularly when dealing with data-holding classes like DTOs (Data Transfer Objects).

- A record is implicitly final and cannot be extended.
- Its fields are final and cannot be modified after creation.
- This makes it thread-safe and prevents unintended modifications.

```java
@ConfigurationProperties(prefix = "accounts")
public record AccountsContactDto(String message, Map<String, String> contactDetails, List<String> onCallSupport) {
}
```

Ensure you have @EnableConfigurationProperties in your configuration class:

```java
@EnableConfigurationProperties(value = {AccountsContactDto.class})
public class AccountsController {
    @Autowired
    private AccountsContactDto contactDto;

    @GetMapping("/contact-info")
    public ResponseEntity<AccountsContactDto> getContactDetails() {
        return ResponseEntity.ok().body(contactDto);
    }
}
```

---

Spring Boot provides **various ways** to manage configurations. The **recommended approach** depends on **how many properties** you need to handle:

- ‚úÖ Use `@Value` for **few** properties.
- ‚úÖ Use `Environment` for **dynamic configurations**.
- ‚úÖ Use `@ConfigurationProperties` for **large sets of properties**.

---

## 3. Managing Configurations with Spring Boot Profiles

In microservices development, different environments (such as **Development, QA, and Production**) often require **different configuration values**. For example, **database credentials** and **API endpoints** should vary between **local development, QA, and production** environments.

Spring Boot provides a powerful feature called **Profiles**, which allows us to define **environment-specific configurations** without modifying the application code.

---

### **Why Use Profiles?**

By default, Spring Boot loads properties from **`application.properties`** or **`application.yml`**. However, these properties **remain the same across all environments**.

‚úÖ **Profiles allow us to:**

- Define **different configuration values** for different environments.
- **Avoid modifying the code** when switching environments.
- **Dynamically activate** the required profile at runtime.
- Control the **creation of Spring beans** based on the active profile.

---

### **How to Define Profiles in Spring Boot**

Spring Boot allows us to **group configurations** into separate profile-specific files:

| Environment         | Configuration File     |
| ------------------- | ---------------------- |
| **Default (Local)** | `application.yml`      |
| **QA**              | `application-qa.yml`   |
| **Production**      | `application-prod.yml` |

#### **Example: Creating Profile-Specific YAML Files**

1Ô∏è‚É£ **Default Configurations (`application.yml`)**

```yaml
spring:
  profiles:
    active: qa
  config:
    import:
      - "application-${spring.profiles.active}.yml"

build:
  version: "3.0"
```

2Ô∏è‚É£ **QA Environment (`application-qa.yml`)**

```yaml
spring:
  config:
    active:
      on-profile: qa

build:
  version: "2.0"
```

3Ô∏è‚É£ **Production Environment (`application-prod.yml`)**

```yaml
spring:
  config:
    active:
      on-profile: prod

build:
  version: "1.0"
```

---

### **Activating a Profile**

We can **activate a profile** using different methods:

#### ‚úÖ **Method 1: Inside `application.yml`**

Add the following property to activate a profile:

```yaml
spring:
  profiles:
    active: qa
```

---

### **Using Profiles to Control Bean Creation**

Profiles can also be used to **conditionally create beans** based on the environment.

```java
@Configuration
@Profile("prod")
public class ProdConfig {

    @Bean
    public DataSource dataSource() {
        return new HikariDataSource(); // Production database connection pool
    }
}
```

If the **`prod` profile** is **active**, Spring will only create this **`dataSource` bean**.

**Key Benefits of Using Profiles**

‚úÖ **Seamless environment switching** ‚Üí No need to modify the code.  
‚úÖ **Prevents sensitive data leakage** ‚Üí Environment variables can store credentials securely.  
‚úÖ **Ensures application consistency** ‚Üí The same **immutable build** can be used across environments.

**Limitations of Using Profiles**: Suppose if I want to change some properties inside a production environment, or suppose if I want to activate the production profile, then I need to change this value and then regenerate the Docker image. With that, we are not making our code base as immutable. That's why let's try to explore what are the various options that we have to change the property values dynamically during the startup through an external parameter.

---

## 4. Externalizing Configurations in Spring Boot

One of the core principles of microservices and cloud-native applications is **externalized configuration**. Instead of **hardcoding profile values** inside `application.yml`, we should activate and manage configurations dynamically based on the deployment environment.

Spring Boot provides multiple ways to achieve this without rebuilding or modifying the application package. Let‚Äôs explore these approaches.

**Why Externalize Configurations?**

If we **hardcode** profile values inside `application.yml`, we must **modify and rebuild** the application whenever we switch environments (e.g., from **Dev to QA to Prod**). This violates the **15-Factor Methodology**, which recommends **immutable artifacts** across deployments.

By **externalizing configurations**, we can:  
‚úÖ Activate different profiles dynamically **without rebuilding the application**.  
‚úÖ Manage **environment-specific settings** separately from the codebase.  
‚úÖ Improve security by keeping **sensitive credentials out of the code**.  
‚úÖ Ensure **portability** across multiple deployment platforms.

### **Approaches for Externalizing Configurations**

Spring Boot provides several methods to activate profiles and set external configurations dynamically.

#### **1Ô∏è‚É£ Command-Line Arguments (Highest Priority)**

Command-line arguments provide the **highest precedence** among all configuration sources in Spring Boot.

##### **Syntax:**

```bash
java -jar myapp.jar --spring.profiles.active=prod --server.port=8082
```
Example:-
```bash
java -jar target/accounts-0.0.1-SNAPSHOT.jar --build.version=5.9
```

##### **Key Points:**

‚úÖ Overrides values set in `application.yml`.  
‚úÖ Allows **dynamic profile selection** at runtime.  
‚úÖ Supports multiple key-value pairs (separated by spaces).

#### **2Ô∏è‚É£ JVM System Properties (-D option)**

JVM system properties provide another way to **pass externalized configurations** at runtime.

##### **Syntax:**

```bash
java -Dspring.profiles.active=prod -Dserver.port=8082 -jar myapp.jar
```
Example:-
```bash
java -Dbuild.version=9.9 -jar target/accounts-0.0.1-SNAPSHOT.jar
```
##### **Key Points:**

‚úÖ Has **lower precedence** than command-line arguments but **higher than application.yml**.  
‚úÖ Allows configurations to be **injected into JVM runtime**.

**Precedence Rule:**  
If **both command-line arguments and JVM system properties** define the same property, **command-line arguments take priority**.

#### **3Ô∏è‚É£ Environment Variables (Universal Approach)**

Environment variables are **universally supported** across all programming languages and platforms, making them a widely used method for external configurations.

##### **Syntax:**

‚úÖ **Windows (Command Prompt)**

```cmd
set SPRING_PROFILES_ACTIVE=prod
java -jar myapp.jar
```

‚úÖ **Linux/macOS (Terminal) or if using GitBash in Windows**

```bash
export SPRING_PROFILES_ACTIVE=qa
java -jar myapp.jar
```

Example:-
```bash
export BUILD_VERSION=8.7
java -jar target/accounts-0.0.1-SNAPSHOT.jar
```

##### **Key Points:**

‚úÖ **Widely supported across all platforms.**  
‚úÖ **No dependency on Java or Spring Boot.**  
‚úÖ Can be **retrieved programmatically** in Java using `System.getenv("SPRING_PROFILES_ACTIVE")`.

üöÄ **Conversion Rules for Environment Variables:**  
When setting Spring Boot properties as environment variables:  
1Ô∏è‚É£ Convert **property keys to uppercase**.  
2Ô∏è‚É£ Replace **dots (.) with underscores (\_)**.

‚úÖ **Example:**  
| Property in `application.yml` | Equivalent Environment Variable |
|----------------------------|----------------------------|
| `build.version=1.0.0` | `BUILD_VERSION=1.0.0` |
| `server.port=8080` | `SERVER_PORT=8080` |

### **Comparison of External Configuration Approaches**

| Approach                   | Priority       | Example Syntax                      |
| -------------------------- | -------------- | ----------------------------------- |
| **Command-Line Arguments** | üî¥ **Highest** | `--spring.profiles.active=prod`     |
| **JVM System Properties**  | üü° Medium      | `-Dspring.profiles.active=qa`       |
| **Environment Variables**  | üü¢ Lower       | `export SPRING_PROFILES_ACTIVE=dev` |
| **application.yml**        | ‚ö™ **Lowest**  | `spring.profiles.active=qa`         |

#### **Best Practices for Externalized Configurations**

‚úî **Use command-line arguments** when deploying in **containerized environments (Docker, Kubernetes)**.  
‚úî **Use environment variables** for cloud-native and **platform-independent configurations**.  
‚úî **Use JVM system properties** when running in **traditional on-premise applications**.  
‚úî **NEVER hardcode sensitive credentials** inside the codebase‚Äîuse a **configuration management system** like Spring Cloud Config.

Spring Boot provides **flexible options** to externalize configurations, ensuring that applications remain **portable, scalable, and environment-agnostic**.

---
